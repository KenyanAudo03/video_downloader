<script>
    const splitLayout = document.getElementById("splitLayout");
const originalLayout = document.getElementById("originalLayout");
const sideVideoFrame = document.getElementById("sideVideoFrame");
const sideVideoGrid = document.getElementById("sideVideoGrid");
const currentVideoTitle = document.getElementById("currentVideoTitle");
const videoGrid = document.getElementById("videoGrid");
const sideLoadingSpinner = document.getElementById("sideLoadingSpinner");
const currentVideoDownloadBtn = document.getElementById(
  "currentVideoDownloadBtn"
);

let nextPage = 2;
let isLoading = false;
let hasMoreVideos = true;
let currentQuery = "{{ query|escapejs }}";
let loadedVideoIds = new Set();
let sideLoadedVideoIds = new Set(); // Separate tracking for side grid
let currentPlayingVideoId = null;
let currentPlayingVideoTitle = null;
let autoNextEnabled = true; // Auto-next is mandatory and enabled by default
let currentVideoIndex = 0;
let allLoadedVideos = []; // Array to track all loaded videos in order
let videoEndCheckInterval = null;
let restrictedVideoSkipTimeout = null; // Timeout for auto-skipping restricted videos

document.addEventListener("DOMContentLoaded", function () {
  const currentVideos = document.querySelectorAll(
    ".searched-video-card[data-video-id]"
  );
  currentVideos.forEach((video, index) => {
    const videoId = video.getAttribute("data-video-id");
    if (videoId) {
      loadedVideoIds.add(videoId);
      // Build initial video list for auto-next
      const title =
        video.querySelector(".searched-video-title")?.textContent ||
        "Unknown Title";
      allLoadedVideos.push({ id: videoId, title: title });
    }
  });
});

function highlightCurrentVideo(videoId) {
  // Remove highlight from all videos
  const allVideoCards = document.querySelectorAll(".searched-video-card");
  allVideoCards.forEach((card) => {
    card.classList.remove("currently-playing");
  });

  // Add highlight to current video
  const currentVideoCards = document.querySelectorAll(
    `[data-video-id="${videoId}"]`
  );
  currentVideoCards.forEach((card) => {
    card.classList.add("currently-playing");
  });
}

function startVideoEndDetection() {
  // Clear any existing interval
  if (videoEndCheckInterval) {
    clearInterval(videoEndCheckInterval);
  }

  // Use postMessage API to communicate with YouTube iframe
  videoEndCheckInterval = setInterval(() => {
    if (sideVideoFrame.contentWindow) {
      try {
        sideVideoFrame.contentWindow.postMessage(
          '{"event":"listening","id":"player"}',
          "*"
        );
      } catch (error) {
        // Silently handle cross-origin restrictions
      }
    }
  }, 1000);
}

function stopVideoEndDetection() {
  if (videoEndCheckInterval) {
    clearInterval(videoEndCheckInterval);
    videoEndCheckInterval = null;
  }
}

function startRestrictedVideoSkipTimer() {
  // Clear any existing timeout
  if (restrictedVideoSkipTimeout) {
    clearTimeout(restrictedVideoSkipTimeout);
  }

  // Set timeout to skip restricted video after 3 seconds
  restrictedVideoSkipTimeout = setTimeout(() => {
    if (currentPlayingVideoId && autoNextEnabled) {
      playNextVideo();
    }
  }, 3000);
}

function clearRestrictedVideoSkipTimer() {
  if (restrictedVideoSkipTimeout) {
    clearTimeout(restrictedVideoSkipTimeout);
    restrictedVideoSkipTimeout = null;
  }
}

// Listen for messages from YouTube iframe
window.addEventListener("message", function (event) {
  if (event.origin !== "https://www.youtube.com") return;

  try {
    const data = JSON.parse(event.data);
    if (data.info) {
      if (data.info.playerState === 0) {
        // Video ended, play next if auto-next is enabled and more videos available
        clearRestrictedVideoSkipTimer(); // Clear skip timer since video ended normally
        if (autoNextEnabled) {
          playNextVideo();
        }
      } else if (data.info.playerState === 1) {
        // Video started playing, clear the restricted video skip timer
        clearRestrictedVideoSkipTimer();
      } else if (data.info.playerState === -1) {
        // Video unstarted - wait a bit then check if it's actually restricted
        setTimeout(() => {
          // If still unstarted after 5 seconds, likely restricted
          if (data.info.playerState === -1) {
            startRestrictedVideoSkipTimer();
          }
        }, 5000);
      }
    }
  } catch (error) {
    // Handle parsing errors silently
  }
});

// Listen for iframe load errors or restricted content
function handleIframeLoad() {
  // Don't start skip timer immediately on load
  // Let the message listener handle player state detection
}

function findCurrentVideoIndex() {
  return allLoadedVideos.findIndex(
    (video) => video.id === currentPlayingVideoId
  );
}

function playNextVideo() {
  const currentIndex = findCurrentVideoIndex();

  if (currentIndex === -1) {
    return;
  }

  const nextIndex = currentIndex + 1;

  // If we're at the end and still loading more videos, wait
  if (nextIndex >= allLoadedVideos.length) {
    if (hasMoreVideos && !isLoading) {
      loadMoreVideos().then(() => {
        // Try again after loading
        setTimeout(() => playNextVideo(), 1000);
      });
      return;
    } else if (!hasMoreVideos) {
      // Optional: Loop back to first video
      // switchVideo(allLoadedVideos[0].id, allLoadedVideos[0].title);
      return;
    }
  }

  const nextVideo = allLoadedVideos[nextIndex];
  if (nextVideo) {
    switchVideo(nextVideo.id, nextVideo.title);
  }
}

function playPreviousVideo() {
  const currentIndex = findCurrentVideoIndex();

  if (currentIndex <= 0) {
    return;
  }

  const previousVideo = allLoadedVideos[currentIndex - 1];
  if (previousVideo) {
    switchVideo(previousVideo.id, previousVideo.title);
  }
}

function openVideoPlayer(videoId, title) {
  if (!videoId) {
    return;
  }

  currentPlayingVideoId = videoId;
  currentPlayingVideoTitle = title;
  currentVideoIndex = findCurrentVideoIndex();

  const embedUrl = `https://www.youtube.com/embed/${videoId}?autoplay=1&rel=0&showinfo=0&modestbranding=1&enablejsapi=1&origin=${window.location.origin}`;

  sideVideoFrame.src = embedUrl;
  sideVideoFrame.onload = handleIframeLoad; // Set up load handler for restricted video detection
  currentVideoTitle.textContent = title;

  // Add keyboard controls info to current video info
  const currentVideoInfo = document.getElementById("currentVideoInfo");
  if (currentVideoInfo) {
    // Remove existing keyboard info if present
    const existingKeyboardInfo = currentVideoInfo.querySelector(
      ".keyboard-controls-info"
    );
    if (existingKeyboardInfo) {
      existingKeyboardInfo.remove();
    }

    // Add keyboard controls info
    const keyboardInfoHTML = `
        <div class="keyboard-controls-info" style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; font-size: 12px; color: #ccc;">
          <strong>Keyboard Controls:</strong><br>
          <span style="display: inline-block; margin-right: 15px;">üîÑ <strong>Auto-Next:</strong> ON (plays next video automatically)</span><br>
          <span style="display: inline-block; margin-right: 15px;">‚è≠Ô∏è <strong>N:</strong> Next video</span>
          <span style="display: inline-block; margin-right: 15px;">‚èÆÔ∏è <strong>P:</strong> Previous video</span>
          <span style="display: inline-block; margin-right: 15px;">‚è© <strong>S:</strong> Skip restricted video</span>
          <span style="display: inline-block; margin-right: 15px;">‚ùå <strong>ESC:</strong> Close player</span><br>
          <span style="display: inline-block; margin-right: 15px;">‚è™‚è© <strong>‚Üê ‚Üí:</strong> Seek backward/forward in video</span><br>
          <span style="font-size: 10px; color: #999;">üí° If video won't play due to restrictions, press 'S' to skip or wait for auto-skip (3s)</span>
        </div>
      `;
    currentVideoInfo.insertAdjacentHTML("beforeend", keyboardInfoHTML);
  }
  sideVideoGrid.innerHTML = "";
  sideLoadedVideoIds.clear(); // Reset side grid tracking

  const currentVideos = videoGrid.querySelectorAll(".searched-video-card");
  currentVideos.forEach((videoCard) => {
    const videoId = videoCard.getAttribute("data-video-id");
    const title = videoCard.querySelector(".searched-video-title").textContent;
    const channelName = videoCard.querySelector(
      ".searched-video-meta span"
    ).textContent;
    const publishedTime = videoCard.querySelector(
      ".searched-video-meta span:last-child"
    ).textContent;
    const thumbnailImg = videoCard.querySelector(".searched-thumbnail-img");
    const duration = videoCard.querySelector(".searched-video-duration");

    sideLoadedVideoIds.add(videoId); // Track in side grid

    const sideVideoHTML = `
        <div class="searched-video-card" data-video-id="${videoId}" onclick="switchVideo('${videoId}', '${title.replace(
      /'/g,
      "\\'"
    )}')">
          <div class="searched-video-thumbnail">
            ${
              thumbnailImg
                ? `<img class="searched-thumbnail-img" src="${thumbnailImg.src}" alt="${title}" loading="lazy" />`
                : '<div class="no-thumbnail">No thumbnail</div>'
            }
            ${
              duration
                ? `<div class="searched-video-duration">${duration.textContent}</div>`
                : ""
            }
          </div>
          <div class="searched-video-info">
            <h3 class="searched-video-title">${title}</h3>
            <div class="searched-video-meta">
              <span>${channelName}</span>
              <span>${publishedTime}</span>
            </div>
          </div>
        </div>
      `;
    sideVideoGrid.insertAdjacentHTML("beforeend", sideVideoHTML);
  });

  // Highlight the currently playing video
  highlightCurrentVideo(currentPlayingVideoId);

  // Show split layout, hide original
  originalLayout.style.display = "none";
  splitLayout.style.display = "flex";

  // Start monitoring for video end
  startVideoEndDetection();
}

function switchVideo(videoId, title) {
  if (!videoId) {
    return;
  }

  // Clear any existing skip timer when switching videos
  clearRestrictedVideoSkipTimer();

  currentPlayingVideoId = videoId;
  currentPlayingVideoTitle = title;
  currentVideoIndex = findCurrentVideoIndex();

  const embedUrl = `https://www.youtube.com/embed/${videoId}?autoplay=1&rel=0&showinfo=0&modestbranding=1&enablejsapi=1&origin=${window.location.origin}`;
  sideVideoFrame.src = embedUrl;
  sideVideoFrame.onload = handleIframeLoad; // Set up load handler for restricted video detection
  currentVideoTitle.textContent = title;

  // Highlight the currently playing video
  highlightCurrentVideo(videoId);

  // Restart video end detection for new video
  startVideoEndDetection();
}

function closeVideoPlayer() {
  sideVideoFrame.src = "";
  splitLayout.style.display = "none";
  originalLayout.style.display = "block";

  // Stop video end detection
  stopVideoEndDetection();

  // Clear restricted video skip timer
  clearRestrictedVideoSkipTimer();

  // Remove all highlights
  const allVideoCards = document.querySelectorAll(".searched-video-card");
  allVideoCards.forEach((card) => {
    card.classList.remove("currently-playing");
  });

  currentPlayingVideoId = null;
  currentPlayingVideoTitle = null;
  currentVideoIndex = 0;
  sideLoadedVideoIds.clear(); // Reset side grid tracking
}

function downloadCurrentVideo() {
  if (currentPlayingVideoId && currentPlayingVideoTitle) {
    downloadVideo(currentPlayingVideoId, currentPlayingVideoTitle);
  } else {
    alert("No video is currently playing");
  }
}

// Keep all your existing functions
function formatViewCount(count) {
  if (!count) return "";

  if (count >= 1000000) {
    return (count / 1000000).toFixed(1) + "M";
  } else if (count >= 1000) {
    return (count / 1000).toFixed(1) + "K";
  }
  return count.toString();
}

function formatDuration(duration) {
  if (!duration) return "";

  const seconds = parseInt(duration);
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const remainingSeconds = seconds % 60;

  if (hours > 0) {
    return `${hours}:${minutes.toString().padStart(2, "0")}:${remainingSeconds
      .toString()
      .padStart(2, "0")}`;
  }
  return `${minutes}:${remainingSeconds.toString().padStart(2, "0")}`;
}

function downloadVideo(videoId, title) {
  if (!videoId) {
    alert("Video ID not available");
    return;
  }

  const downloadUrl = `/search/download-video/?id=${videoId}&title=${encodeURIComponent(
    title
  )}`;

  const link = document.createElement("a");
  link.href = downloadUrl;
  link.download = `${title}.mp4`;
  link.style.display = "none";
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

function createSideVideoCard(video) {
  // Use separate tracking for side grid
  if (sideLoadedVideoIds.has(video.id)) {
    return null;
  }

  sideLoadedVideoIds.add(video.id);

  const duration = video.duration || "";
  const channelName = video.channel ? video.channel.name : "Unknown Channel";
  const publishedTime = video.publishedTime || "";
  const thumbnailUrl =
    video.thumbnails && video.thumbnails.length > 0
      ? video.thumbnails[0].url
      : "";

  return `
      <div class="searched-video-card" data-video-id="${
        video.id
      }" onclick="switchVideo('${video.id}', '${video.title.replace(
    /'/g,
    "\\'"
  )}')">
        <div class="searched-video-thumbnail">
          ${
            thumbnailUrl
              ? `<img class="searched-thumbnail-img" src="${thumbnailUrl}" alt="${video.title}" loading="lazy" />`
              : '<div class="no-thumbnail">No thumbnail</div>'
          }
          ${
            duration
              ? `<div class="searched-video-duration">${duration}</div>`
              : ""
          }
        </div>
        
        <div class="searched-video-info">
          <h3 class="searched-video-title">${video.title}</h3>
          <div class="searched-video-meta">
            <span>${channelName}</span>
            ${publishedTime ? `<span>${publishedTime}</span>` : ""}
          </div>
        </div>
      </div>
    `;
}

function createVideoCard(video) {
  if (loadedVideoIds.has(video.id)) {
    return null;
  }

  loadedVideoIds.add(video.id);

  // Add to allLoadedVideos for auto-next functionality
  allLoadedVideos.push({ id: video.id, title: video.title });

  let viewCount = "";
  if (video.shortViews) {
    viewCount = video.shortViews;
  } else if (video.viewCount) {
    if (typeof video.viewCount === "object" && video.viewCount.simpleText) {
      viewCount = formatViewCount(
        parseInt(video.viewCount.simpleText.replace(/[^0-9]/g, ""))
      );
    } else if (typeof video.viewCount === "string") {
      viewCount = video.viewCount;
    }
  }

  const duration = video.duration || "";
  const channelName = video.channel ? video.channel.name : "Unknown Channel";
  const publishedTime = video.publishedTime || "";
  const thumbnailUrl =
    video.thumbnails && video.thumbnails.length > 0
      ? video.thumbnails[0].url
      : "";

  return `
      <div class="searched-video-card" data-video-id="${video.id}">
        <div class="searched-video-thumbnail" onclick="openVideoPlayer('${
          video.id
        }', '${video.title.replace(/'/g, "\\'")}')">
          ${
            thumbnailUrl
              ? `<img class="searched-thumbnail-img" src="${thumbnailUrl}" alt="${video.title}" loading="lazy" />`
              : '<div class="no-thumbnail">No thumbnail</div>'
          }
          
          ${
            duration
              ? `<div class="searched-video-duration">${duration}</div>`
              : ""
          }
          ${
            viewCount
              ? `<div class="searched-video-views">${viewCount}${
                  viewCount.includes("views") ? "" : " views"
                }</div>`
              : ""
          }
          
          <div class="searched-play-overlay">
            <div class="searched-play-icon"></div>
          </div>
        </div>
        
        <div class="searched-video-info">
          <h3 class="searched-video-title">${video.title}</h3>
          <div class="searched-video-meta">
            <span>${channelName}</span>
            ${publishedTime ? `<span>${publishedTime}</span>` : ""}
          </div>
          <button class="download-btn" onclick="downloadVideo('${
            video.id
          }', '${video.title.replace(/'/g, "\\'")}')">
            <svg class="download-icon" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd"></path>
            </svg>
            Download
          </button>
        </div>
      </div>
    `;
}

async function loadMoreVideos() {
  if (isLoading || !hasMoreVideos || !currentQuery) return;

  isLoading = true;
  const loadingSpinner = document.getElementById("loadingSpinner");
  const sideLoadingSpinner = document.getElementById("sideLoadingSpinner");

  // Show appropriate loading spinner
  if (splitLayout.style.display === "flex") {
    sideLoadingSpinner.style.display = "block";
  } else {
    loadingSpinner.style.display = "block";
  }

  try {
    const response = await fetch(
      `/search/search-video/?q=${encodeURIComponent(
        currentQuery
      )}&page=${nextPage}`
    );

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();

    if (data.error) {
      hasMoreVideos = false;
      return;
    }

    if (data.results && data.results.length > 0) {
      let newVideosAdded = 0;

      data.results.forEach((video) => {
        // Add to main grid
        const videoCardHTML = createVideoCard(video);
        if (videoCardHTML) {
          videoGrid.insertAdjacentHTML("beforeend", videoCardHTML);
          newVideosAdded++;
        }

        // Add to side grid if it's visible
        if (splitLayout.style.display === "flex") {
          const sideVideoHTML = createSideVideoCard(video);
          if (sideVideoHTML) {
            sideVideoGrid.insertAdjacentHTML("beforeend", sideVideoHTML);
          }
        }
      });

      // Re-highlight current video after adding new videos
      if (currentPlayingVideoId) {
        highlightCurrentVideo(currentPlayingVideoId);
      }

      if (newVideosAdded > 0) {
        nextPage++;
      }

      if (
        data.has_more === false ||
        data.results.length < 10 ||
        newVideosAdded === 0
      ) {
        hasMoreVideos = false;
      }
    } else {
      hasMoreVideos = false;
    }
  } catch (error) {
    hasMoreVideos = false;
  } finally {
    isLoading = false;
    loadingSpinner.style.display = "none";
    sideLoadingSpinner.style.display = "none";
  }
}

function handleContentAreaScroll() {
  const contentArea = document.querySelector(".content-area");
  const videoListSection = document.querySelector(".video-list-section");

  // Handle scroll for split layout
  if (splitLayout.style.display === "flex" && videoListSection) {
    const scrollTop = videoListSection.scrollTop;
    const scrollHeight = videoListSection.scrollHeight;
    const clientHeight = videoListSection.clientHeight;

    if (scrollTop + clientHeight >= scrollHeight - 100) {
      loadMoreVideos();
    }
    return;
  }

  // Handle scroll for original layout
  if (!contentArea) return;

  const scrollTop = contentArea.scrollTop;
  const scrollHeight = contentArea.scrollHeight;
  const clientHeight = contentArea.clientHeight;

  if (scrollTop + clientHeight >= scrollHeight - 100) {
    loadMoreVideos();
  }
}

function initializeScrollListener() {
  const contentArea = document.querySelector(".content-area");
  const videoListSection = document.querySelector(".video-list-section");

  if (contentArea) {
    contentArea.addEventListener("scroll", handleContentAreaScroll);
  }

  if (videoListSection) {
    videoListSection.addEventListener("scroll", handleContentAreaScroll);
  }

  if (!contentArea && !videoListSection) {
    window.addEventListener("scroll", function () {
      const scrollTop =
        document.documentElement.scrollTop || document.body.scrollTop;
      const scrollHeight =
        document.documentElement.scrollHeight || document.body.scrollHeight;
      const clientHeight =
        document.documentElement.clientHeight || window.innerHeight;

      if (scrollTop + clientHeight >= scrollHeight - 100) {
        loadMoreVideos();
      }
    });
  }
}

document.addEventListener("DOMContentLoaded", function () {
  initializeScrollListener();
});

if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", initializeScrollListener);
} else {
  initializeScrollListener();
}

// Keyboard shortcuts
document.addEventListener("keydown", (e) => {
  if (splitLayout.style.display === "flex") {
    switch (e.key) {
      case "Escape":
        closeVideoPlayer();
        break;
      case "n":
      case "N":
        e.preventDefault();
        playNextVideo();
        break;
      case "p":
      case "P":
        e.preventDefault();
        playPreviousVideo();
        break;
      case "s":
      case "S":
        e.preventDefault();
        playNextVideo();
        break;
    }
  }
});

// Expose functions for manual control (optional)
window.videoPlayerControls = {
  playNext: playNextVideo,
  playPrevious: playPreviousVideo,
  toggleAutoNext: function () {
    autoNextEnabled = !autoNextEnabled;
    return autoNextEnabled;
  },
  isAutoNextEnabled: function () {
    return autoNextEnabled;
  },
};

</script>